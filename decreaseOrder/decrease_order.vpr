import "decreaseOrder/tuple.vpr"
//import "tuple.vpr"

domain TerminationOrder[T]{
    function decreasing(arg1:T, arg2:T):Bool
    function bounded(arg1:T):Bool 
}

domain IntTerminationOrder{
	//Integers
    axiom integer_ax_dec{
        forall int1: Int, int2: Int :: //{decreasing(int1, int2)}
        (int1 < int2) ==> decreasing(int1, int2)
        //false ==> decreasing(int1, int2)
    }
    axiom integer_ax_bound{
        forall int1: Int :: 
        int1 >= 0 ==> bounded(int1)
    }
}

domain BoolTerminationOrder{
    //Booleans
    axiom bool_ax_dec{
        forall bool1: Bool ::
        bool1 != false ==> decreasing(bool1, false)
    }
    axiom bool_ax_bound{
        forall bool1: Bool :: 
        bounded(bool1)
    }
}

domain RefTerminationOrder{
    //References
	axiom ref_ax_dec{
        forall ref1: Ref :: 
        ref1 != null ==> decreasing(null, ref1)
    }
    axiom ref_ax_bound{
        forall ref1: Ref :: 
        bounded(ref1)
    }
}

//Rationals
// axiom rational_ax{
//     forall rat1: Rational, rat2: Rational :: {decreasing(rat1, rat2)}
//     (rat1 >= 0 && rat1 < rat2) ==> decreasing(rat1, rat2)
// }
    
domain SeqTerminationOrder[S]{
    //Sequences
    axiom seq_ax_dec{
       forall seq1: Seq[S], seq2: Seq[S] :: //{decreasing(seq1,seq2)}
       (|seq1| < |seq2|) ==> decreasing(seq1, seq2)
    }
    axiom seq_ax_bound{
       forall seq1: Seq[S] ::
       (|seq1| >= 0) ==> bounded(seq1) //Unnecessary i think
    }
}

domain SetTerminationOrder[S]{
    //Sets
    axiom set_ax_dec{
        forall set1: Set[S], set2: Set[S] :: {decreasing(set1, set2)}
        ((forall s:S :: s in set1 ==> s in set2) && (|set1| < |set2|)) ==> decreasing(set1, set2)
    }
    axiom set_ax_bound{
        forall set1: Set[S] :: bounded(set1)
    }
}

domain MuliSetTerminationOrder[S]{
    //MultiSet
    axiom multiSet_ax_dec{
        forall mSet1: Multiset[S], mSet2: Multiset[S] :: {decreasing(mSet1, mSet2)}
        ((forall s:S :: (s in mSet1) <= (s in mSet2)) && (|mSet1| < |mSet2|)) ==> decreasing(mSet1, mSet2)
    }
    axiom multiSet_ax_bound{
        forall mSet1: Multiset[S] :: bounded(mSet1)
    }
}

domain PermTerminationOrder{  
    //permission
    axiom perm_ax_dec{
        forall perm1: Perm, perm2: Perm :: {decreasing(perm1, perm2)}
        (perm1 < perm2) ==> decreasing(perm1, perm2)
    }
    axiom perm_ax_bound{
        forall perm1: Perm ::
        bounded(perm1) //given that permissions are always positive
    }  
}

domain Tuple2TerminationOrder[A,B]{
    //2 Tuples
    axiom tuple_ax_dec2{
         forall t1: Tuple2[A,B], t2: Tuple2[A,B] :: {decreasing(t1,t2)}
         decreasing(first2(t1),first2(t2)) ||
         (first2(t1) == first2(t2) && decreasing(second2(t1),second2(t2)))
         ==> decreasing(t1,t2)
    }
    axiom tuple_ax_bound2{
        forall t1: Tuple2[A,B] ::
        (bounded(first2(t1)) && bounded(second2(t1))) ==> bounded(t1) //TODO not sure
    }
}

domain Tuple3TerminationOrder[A,B,C]{
    //3 Tuples
    axiom tuple_ax_dec3{
         forall t1: Tuple3[A,B,C], t2: Tuple3[A,B,C]:: {decreasing(t1,t2)}
         decreasing(first3(t1),first3(t2)) ||
         (first3(t1) == first3(t2) && decreasing(second3(t1),second3(t2))) ||
         (first3(t1) == first3(t2) && second3(t1) == second3(t2) && decreasing(second3(t1),second3(t2)))
         ==> decreasing(t1,t2)
    }
    axiom tuple_ax_bound3{ 
        forall t1: Tuple3[A,B,C] ::
        (bounded(first3(t1)) && bounded(second3(t1)) && bounded(third3(t1))) ==> bounded(t1) //TODO not sure
    }
}

