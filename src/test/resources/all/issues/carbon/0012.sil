//:: IgnoreFile(/silicon/issue/105/)

field f : Ref

method allocTest(x: Ref) {
  var y: Ref
  var z: Ref := x
 
  while (false) {
    z := z // value of z is havoced
  }
  
  y := new()
  //:: UnexpectedOutput(assert.failed:assertion.false, /dummy/issue/0004/)
  assert x != y
  //:: UnexpectedOutput(assert.failed:assertion.false, /dummy/issue/0004/)
  assert z != y
  
  inhale acc(x.f)
  //:: UnexpectedOutput(assert.failed:assertion.false, /dummy/issue/0004/)
  assert y != x.f
  inhale acc(y.f)
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert x != y.f
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert x != x.f
  
  exhale acc(x.f) && acc(y.f)

  // check allocated information preserved over exhale
  assert x != y
  assert z != y
  
  z := m()
  y := new()
  
  //:: UnexpectedOutput(assert.failed:assertion.false, /dummy/issue/0004/)
  assert x != y
  //:: UnexpectedOutput(assert.failed:assertion.false, /dummy/issue/0004/)
  assert z != y
  
  inhale acc(x.f)
  //:: UnexpectedOutput(assert.failed:insufficient.permission, /dummy/issue/0004/)
  assert y != x.f
  inhale acc(y.f)
  //:: UnexpectedOutput(assert.failed:insufficient.permission, /dummy/issue/0004/)
  //:: MissingOutput(assert.failed:assertion.false, /dummy/issue/0004/)
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert x != y.f
  //:: UnexpectedOutput(assert.failed:insufficient.permission, /dummy/issue/0004/)
  //:: MissingOutput(assert.failed:assertion.false, /dummy/issue/0004/)
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert x != x.f  
}

method m() returns (r:Ref) {
  r := new()
}