field f: Int

method m1(x: Ref, y: Ref) {
    inhale p1(x, 0)
    inhale p1(y, 10)

    assert forperm a:Ref, i: Int [p1(a,i)] :: i >= 0
}

method m2(x: Ref, y: Ref, z: Ref) {
    inhale p2(x, y)
    inhale p2(z, y)
    inhale x != z

    assert !forperm a: Ref [p2(a,y)] :: a == z
    unfold p2(x,y)
    assert forperm a: Ref [p2(a,y)] :: a == z
}

method m3(x: Ref, y: Ref, z: Ref) {
    inhale p3(x,y)
    inhale p3(z,z)
    inhale x != y

    assert forperm a: Ref [p3(a,a)] :: a == z
}

method m4(x: Ref, y: Ref, z: Ref) {
    inhale p3(x,y)
    inhale p3(y,z)
    inhale z != y

    assert forperm a: Ref [p3(a,y)] :: a == x
}

method m5(x: Ref, y: Ref) {
    inhale p1(x,10)
    inhale p1(y, 15)

    if (forperm a: Ref, i: Int [p1(a,i)] :: a == x) {
        assert x == y
    } else {
        assert x != y
    }
}

method m6(x: Ref, y: Ref) {
    inhale p2(x,y)
    inhale p3(y,x)

    assert forperm a: Ref, b: Ref [p2(a,b)] :: x != y ==> a != y
}

predicate p1(x: Ref, i: Int) {
    acc(x.f) && x.f > i
}

predicate p2(x: Ref, y: Ref) {
    acc(x.f) && acc(y.f) && x.f > y.f
}

predicate p3(x: Ref, y: Ref) {
    acc(x.f) && acc(y.f)
}