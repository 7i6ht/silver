field f: Int
field next: Ref

method proof_script(x: Ref)
    requires acc(x.f)
{
    x.f := 5
    package acc(x.f) && x.f == 7 --* false
    {
        assert acc(x.f) && acc(x.f)
        assert acc(x.f) && acc(x.f)
    }
}

method proof_script_aliasing(x: Ref, y: Ref)
    requires acc(x.f, 1/2) && acc(y.f, 1/2)
{
    package acc(x.f, 1/2) && acc(y.f, 1/2) --* x != y
    {
        assert acc(x.f) && acc(y.f)
    }
}


predicate P(x: Ref)

method pred(x: Ref)
{
    package P(x) --* P(x)
}

method pred2(x: Ref, y: Ref)
    requires P(x) && P(y)
    ensures acc(P(x), 3/4) && P(y)
{
    package acc(P(x), 1/4) --* acc(P(x), 1/2)
}



method mainNeg(x: Ref)
    requires acc(x.f)
    ensures acc(x.f, 1/2)
{
    package acc(x.f, -1/2) --* acc(x.f)
}


method mainOK(x: Ref)
    requires acc(x.f)
    ensures acc(x.f, 1/2)
{
    package acc(x.f, 1/2) --* acc(x.f)
}

method general_issue(x: Ref, y: Ref)
    requires acc(x.f)
{
    // footprint:
    // acc(x.f, 1/2 + wildcard)
    package acc(x.f, 1/2) --* acc(x.f, 3/2)
}

method not_work(x: Ref, y: Ref)
    requires acc(x.f, 1/3) && acc(y.f, 1/3)
{
    // if x == y:
    // LHS is acc(x.f, 1/3) && acc(y.f, 1/3), but RHS is "false"

    package acc(x.f, 1/3) && acc(y.f, 1/3) --* acc(x.f, 2/3) && acc(y.f, 2/3)
}


method works(x: Ref, y: Ref)
    requires acc(x.f, 1/2) && acc(y.f, 1/2)
{
    // if x == y: Binary
    package acc(x.f, 1/2) && acc(y.f, 1/2) --* acc(x.f) && acc(y.f) && x != y
}

method shouldBeWrong(x: Ref, y: Ref)
    requires acc(x.next, 1/2) && acc(y.next, 1/2) && acc(x.next.f) && acc(y.next.f)
{
    package acc(x.next, 1/2) && acc(y.next, 1/2) && acc(x.next.f, 1/2) && acc(y.next.f, 1/2) --*
        acc(x.next) && acc(y.next) && acc(x.next.f) && acc(y.next.f) && x.next != y.next
}




method testFalse(x: Ref)
    requires acc(x.f, 1/2)
{
    package acc(x.f) --* acc(x.f, 3/2)
}