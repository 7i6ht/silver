//:: IgnoreFile(/silicon/issue/0000000000000/)
field val: Int
field next: Ref

predicate List(x: Ref) {
    acc(x.val) && acc(x.next) && (x.next != null ==> List(x.next))
}

function getHead(x: Ref): Int
requires List(x) {
    unfolding List(x) in x.val
}

method test0(x: Ref)
requires List(x)
ensures List(x) && getHead(x) == old(getHead(x)) {
    var iter: Ref := x
    package List(iter) --* List(x)
    unfold List(iter)
    while (iter.next != null)
    invariant acc(iter.val) && acc(iter.next)
    invariant List(iter) --* List(x)
    invariant iter.next != null ==> List(iter.next) {
        var oldIter: Ref := iter
        iter := iter.next
        unfold List(iter)
        package List(iter) --* List(x) {
            fold List(oldIter)
            apply List(oldIter) --* List(x)
        }
    }
    fold List(iter)
    apply List(iter) --* List(x)
}

method test0a(x: Ref)
requires List(x)
ensures List(x) && getHead(x) == old(getHead(x)) {
    var iter: Ref := x
    unfold List(iter)
    if (iter.next != null) {
        var oldIter: Ref := iter
        iter := iter.next
        unfold List(iter)
        package List(iter) --* List(x) && getHead(x) == old(getHead(x)) {
            fold List(oldIter)
        }
        while (iter.next != null)
        invariant acc(iter.val) && acc(iter.next)
        invariant List(iter) --* List(x) && getHead(x) == old(getHead(x))
        invariant iter.next != null ==> List(iter.next) {
            oldIter := iter
            iter := iter.next
            unfold List(iter)
            package List(iter) --* List(x) && getHead(x) == old(getHead(x)) {
                fold List(oldIter)
                apply List(oldIter) --* List(x) && getHead(x) == old(getHead(x))
            }
        }
        fold List(iter)
        apply List(iter) --* List(x) && getHead(x) == old(getHead(x))
    } else {
        fold List(iter)
    }
}