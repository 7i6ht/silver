field f: Int

method foo(xs: Seq[Ref], y: Ref)
requires forall x: Ref :: x in xs ==> acc(x.f)
requires forall i: Int, j: Int :: 0 <= i && 0 <= j && i < |xs| && j < |xs| && i != j ==> xs[i] != xs[j]
requires |xs| >= 1
requires acc(y.f) {
    xs[0].f := 0
    y.f := 1
    label setupComplete
    var toGo: Seq[Ref] := xs
    var completed: Seq[Ref] := Seq()
    while (|toGo| != 0)
    invariant forall x: Ref :: x in completed ==> acc(y.f) --* acc(x.f) && acc(y.f) && y.f == old[lhs](y.f)
    invariant forall i: Int, j: Int :: 0 <= i && 0 <= j && i < |toGo| && j < |toGo| && i != j ==> toGo[i] != toGo[j]
    invariant forall x: Ref :: x in toGo ==> acc(x.f)
    invariant xs == completed ++ toGo
    invariant forall x: Ref :: x in toGo ==> x.f == old[setupComplete](x.f)
    invariant acc(y.f) && y.f == 1
    invariant forall x: Ref :: x in completed ==>
      applying (acc(y.f) --* acc(x.f) && acc(y.f) && y.f == old[lhs](y.f)) in
      x.f == old[setupComplete](x.f) {
        var localX: Ref := toGo[0]
        package acc(y.f) --* acc(localX.f) && acc(y.f) && y.f == old[lhs](y.f)
        completed := completed ++ Seq(localX)
        toGo := toGo[1..]
    }
    assert forall x: Ref :: x in xs ==> acc(y.f) --* acc(x.f) && acc(y.f) && y.f == old[lhs](y.f)
    var some: Ref := xs[0]
    apply acc(y.f) --* acc(some.f) && acc(y.f) && y.f == old[lhs](y.f)
    assert some.f == 0
    assert y.f == 1
}